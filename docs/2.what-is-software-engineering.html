---
layout: presentation
title: What is Software Engineeering
permalink: /what-is-software-engineering/
---

class: center, middle

# Software Engineering
What is it?
Why is it useful?

---

# Agenda

1. [Attempts at a definition](#definition)
2. [Confusion by job title](#titles)
3. [Definition by antithesis](#antithesis)
4. [Challenges](#challenges)
5. [Intrusion of DevOps](#devops)
6. [Development lifecycle](#lifecycle)
7. [Process models](#models)
8. [Conclusions](#conclusions)

---

class: center, middle
name: definition

# Attempts at a definition

---

# Attempts at a definition
## Wikipedia

> Software engineering is the application of engineering to the development of software in a systematic method. 
> 
> --- [Wikipedia](https://en.wikipedia.org/wiki/Software_engineering)

---

# Attempts at a definition
## IEEE

> The application of a systematic, disciplined, quantifiable approach to the development, operation, and maintenance of software; that is, the application of engineering to software. 
> 
> --- IEEE Standard 610.12

---

# Attempts at a definition
## ACM

> Software engineering is concerned with developing and maintaining software systems that behave reliably and efficiently, are affordable to develop and maintain, and satisfy all the requirements that customers have defined for them.
> 
> --- ACM

---

# Attempts at a definition
## Merriam-Webster

> A branch of computer science that deals with the design, implementation, and maintenance of complex computer programs.
> 
> --- Merriam-Webster

---

# Attempts at a definition
## Foo Barstein

> Software engineerings is the systematic approach to creating software that uses empirical, evidence-based social and practical knowledge to invent, innovate, design, build, maintain, research, and improve software.
> 
> --- Foo Barstein

---

class: center, middle
name: titles

# Confusion by job title

---

# Confusion by job title
## Useless

Job titles vary wildly in industry.  For example, each of these titles may or may not be for the role and responsibilities of a software engineeer - there is no way to know.
- Software engineer
- Software developer
- Software architect
- IT consultant
- IT specialist
- Systems analyst
- Developer
- Coder
- Programmer
- Ninja
- Requirements engineer
- Testing engineer
- Q/A engineer
... and many more

---

class: center, middle
name: antithesis

# Definition by antithesis

---

name: software-crisis

# Definition by antithesis
## The Software Crisis

Software engineering originated during the turbulent times of the 1960's, when people began to realize it was a rare project which resulted in efficient and well-functioning software in a reasonable amount of time at a reasonable cost.

---

template: software-crisis

This became known as the great Software Crisis!

---

# Definition by antithesis
## The Software Crisis

"[Software’s Chronic Crisis](https://knowledge.kitchen/mediawiki/images/e/e5/Software%27s_Chronic_Crisis.pdf)", Scientific American, Sept. 1994:
> By the time [the art of programming] reached 25, the difficulties of building big software loomed so large that in the autumn of 1968 the NATO Science Committee convened some 50 top programmers, computer scientists and captains of industry to plot a course out of what had come to be known as the software crisis. Although the experts could not contrive a road map to guide the industry toward firmer ground, they did coin a name for that distant goal: software engineering, now defined formally as “the application of a systematic, disciplined, quantifiable approach to the development, operation and maintenance of software.”
> 
> A quarter of a century later software engineering remains a term of aspiration.


---

name: bespoke-dev-1

# Definition by antithesis
## Bespoke development

Today, the antagonist to our protagonist is the **bespoke** developer - an individual or team who work take a unique custom-tailored approach to every project.

---

template: bespoke-dev-1
name: bespoke-dev-2

Bespoke development can produce beautiful works of art perectly fitted to the customer's needs.

---

template: bespoke-dev-2
name: bespoke-dev-3

Software engineers, in contrast, streamline development such that the work references genericized norms, best-practices, standards, and patterns known to many developers and shared by many projects in the field.

---

template: bespoke-dev-3

In other words, software engineers are the fry cooks of the industrial software development assembly line.

---

# Definition by antithesis
## Bespoke development

The ideal of artisanal work is much pined for for its uniqueness and attention to detail.

But artisanal approaches do not scale well because...
- Software is increasingly complex.
- Demand for software is everywhere and increasing.
- Artisanal approaches are, by nature, time consuming and expensive.

---

class: center, middle
name: challenges

# Challenges

---

# Challenges
## Software is abstract

Linus Torvalds (creator of Git and the Linux kernel), [CNN interview from 2000](https://www.youtube.com/watch?v=NKkvPxYNh9A&list=PLWJSC31EgeIwOCrFySTNyBDKUUGV2W5lr):
> You have much more freedom than you have when you're building a bridge or a building.  You can pretty much make up your own rules. [...] It is artistry... at least for good programmers.

The bits and bytes on the machine are not constrained by physical limitations, limits in manufacturing, or transportation logistics. This allows for the development of a wild variety of systems - virtually any idea can be turned into software with little overhead.

This same lack of constraints allows for glutonous programmers to write code that can become increasingly complicated, deep, and difficult to maintain.

---

# Challenges
## Software is increasingly complex

[Fred Brooks](https://en.wikipedia.org/wiki/Brooks%27s_law), from "The Mythical Man-Month":
> Adding manpower to a late software project makes it later.

Creating quality software is hard, especially on a large scale
- Developer onboarding
- System complexity
- Client expectations

---

# Challenges
## Software is not just a program

Well-designed, functional, maintainable software usually includes many artifacts besides a program:
- documentation
- configuration data
- libraries
- data storage resources
- supportive web sites

---

# Challenges
## Demand for software is increasing

From the [Bureau of Labor Statistics summary of Software Developer jobs](https://www.bls.gov/ooh/computer-and-information-technology/software-developers.htm):
- **2018 Median Pay:** $105,590 per year / $50.77 per hour
- **Typical Entry-Level Education:** Bachelor's degree
- **Work Experience in a Related Occupation:** None
- **Work Experience in a Related Occupation:** None
- **On-the-job Training:** None
- **Number of Jobs, 2018:** 1,365,500
- **Job Outlook, 2018-28:** 21% (Much faster than average)
- **Employment Change, 2018-28:** 284,100

---

# Challenges
## Software must ideally be delivered on-time on-budget

Engineering is the application of science and knowledge to practical applications. Software engineering aims to produce real-world software that can be used by its customers to solve their problems.

There is almost universally a budget and a deadline.  Engineers must figure out how to solve the problem with those constraints.

---

class: center, middle
name: devops

# Intrusion of DevOps

---

# Intrusion of DevOps
## Merging Development with Operations

DevOps is the fusion of...
- Development (writing code) 
- Operations (IT tools and infrastructure)

Formerly considered disparate disciplines, in contemporary thought, operations functions are either incorporated into the workload of developers, or managed by IT specialists working in close communication with developers.

---

# Intrusion of DevOps
## Relying on automation

How Operations can be merged with Development is largely explained by the rise of automation.

Automated tools and virtualization now allow developers to trigger formerly time- and resource-consuming IT operations with minimal setup and wait time and minimal reliance on humans.

Operations such as the following are now often done with the assistance of automated tools:
- setting development and production environments
- monitoring progress
- testing
- deploying
- securing applications

---

class: center, middle
name: lifecycle

# Development lifecycle

---

# Development lifecycle
## Phases of development

Regardless of process model, the phases of development are familiar to all:
- Specification
- Implementation
- Validation
- Evolution

Rinse and repeat.

---

# Development lifecycle
## Specification

Figuring out as much as you can about what the system will do and how it will do it.

---

# Development lifecycle
## Implementation

Writing the code, designing the interface, writing the text, building the systems, making it work according to plan, etc.

---

# Development lifecycle
## Validation

Does it work?  Is it what you planned?

---

# Development lifecycle
## Evolution

- Bug fixes
- New features

---

# Development lifecycle
## Iterations

- In Big Design Up-Front methodologies, we perform these phases once for the entire project at inception.
- In Incremental development methodologies, we repeat these phases many times for pieces of the project at discrete intervals.

---

class: center, middle
name: models

# Process models

---

# Process models
## Big Design Up-Front

In Big Design Up-Front methodologies, such as "Waterfall", we perform each of the lifecycle phases once for the entire project at inception.

---

# Process models
## Big Design Up-Front

With Big Design Up-Front/Waterfall, once a specification has been drafted and agreed upon ('signed-off on'), estimating project cost and completion date is, in theory, straightfoward, since everyone has agreed exactly what is to be done and how it will be done.

---

# Process models
## Big Design Up-Front

In Big Design Up-Front/Waterfall methodologies, each phase must be completed and 'signed off' before the next phase can begin.

Since there is only one iteration of each phases, these phases typically take a long time.  The project needs might change during that time.

Any change requires a rewriting of the entire specification and another 'sign-off' from the client and re-doing of any work already done in subsequent phases.

---

# Process models
## Incremental methodologies

In Incremental development methodologies, such as the so-called "Agile" methodologies, the work to be done is broken up into increments, and developers repeat these phases many times for each piece/increment of the project at discrete intervals.  

---

# Process models
## Incremental methodologies

In Incremental/Agile methodologies, since work is broken up into discrete increments with their own lifecycle phases, any changes to the project only affect the current iteration, not the project as a whole.

---

# Process models
## Incremental methodologies

In Incremental/Agile methodologies, since specification and the other phases only happen in increments, there is no holistic view of how long the project will take nor how much it will cost.

Incremental/Agile development, in a purist sense, therefore is only feasible when unlimited money and unlimited time are available.

---

# Process models
## Incremental methodologies

Since unlimited funds and time are usually not available, many Incremental/Agile development practitioners put fixed time limits and money limits on the project, and try to complete as much as possible in that time for that money.

---

# Process models
## Incremental methodologies

Since the project may not be fully completed before time and money run out, Incremental/Agile developers *try* to have each increment be a runnable product that may not be feature-complete, but will be functional as-is, even if no more work is to be done on the project.

---

class: center, middle
name: conclusions

# Conclusions

---

# Conclusions
Thank you. Bye.

