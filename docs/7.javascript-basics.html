---
layout: presentation
title: Introduction to Javascript
permalink: /javascript-intro/
---

class: center, middle

# Javascript Crash Course
for programmers of other languages

---

# Agenda

1. [Overview](#overview)
1. [The Basics](#basics)
1. [Objects](#objects)
1. [Functions](#functions)
1. [Arrays](#arrays)
1. [Higher-Order Functions](#higher-order-functions)
1. [Asynchronicity](#asynchronicity)
1. [Using APIs](#apis)
1. [Destructuring](#destructuring)
1. [Importing & Exporting Modules](#modules)
1. [Web Browser Implementation vs Node.js Implementation](#implementations)
10. [Conclusions](#conclusions)

---

name: overview

# Overview

---

template: overview
name: overview-1

## Concept
Javascript, also known as ECMAScript, has a few unusual features that trouble programmers of other languages.

---

template: overview-1
name: overview-2

- loose typing of variables

---

template: overview-2
name: overview-3

- prototypal inheritance (no classes!)

---

template: overview-3
name: overview-4

- insular jargon like 'hoisting', 'closures', 'destructuring', and 'unpacking'

---

template: overview-4
name: overview-5

- two comparison operators, == and ===

---

template: overview-5
name: overview-6

- at least 5 different syntaxes for defining functions

---

template: overview-6
name: overview-7

- two very different common use-cases: client-side and server-side programming

---

template: overview-7
name: overview-8

- three different ways to handle asynchronousity

---

template: overview
name: overview-9

Try out the code examples in this deck for yourself: https://repl.it/@foobarstein/node-js-examples

---

name: basics

# The Basics

---

template: basics
name: variables

## Variable declaration
Three keywords to declare a variable:
- **let** - for defining block-scoped variables
- **const** - for defining block-scoped variables that cannot be reassigned to a new value
- **var** - for defining function-scoped variables, or global variables if not declared within a function... present for legacy purposes and should not be used in new code

---

template: basics
name: variables-1

## Let example

```javascript
// non-constant variables are declared with the let keyword 
let it = true; // it's true!

it = (it) ? false : true; // reassign it to be its opposite using the ternary operator

console.log(`It is ${it}!`); // expected output: 'It is false!'
```

[Try it!](https://repl.it/repls/BlandFlickeringPolygon)

---

template: basics
name: variables-2

## Const example

```javascript
// constants are declared with the const keyword
const data = [10, 20, 30];  // a variable that can't be reassigned!

data[1] = 'ha!'; // but this is not variable reassignment!

console.log(data); // expected output: [10, 'ha!', 30]
```

---

template: basics
name: output-1

## Output to console
`console.log()` outputs text to the console.

Basic usage
```javascript
let stuff = 'some text';

console.log('This is ' + stuff + '.'); // expected output: 'This is some text.'
```

[Try it!](https://repl.it/repls/EarnestLankyCable)

---

template: output-1
name: output-2

Template syntax enapsulating a string with backtics
```javascript
let stuff = 'some text';

console.log(`This is ${stuff}.`); // expected output: 'This is some text.'
```

[Try it!](https://repl.it/repls/FirsthandRoastedAmoebas)


---

template: output-2
name: output-3

Template syntax will accept any expression
```javascript
const x = 5;
const y = 10;

console.log(`The result is ${ x + y }.`); // expected output: 'The result is 15.'
```

[Try it!](https://repl.it/repls/ColorfulProfitableLocatorprogram)

---

template: basics
name: for-loops-1

## For loops
The expected behavior.

```javascript
// iterate 5 times
for (let i=1; i<6; i++) {
    console.log(`For loop iteration #${i}`);
}
```

[Try it!](https://repl.it/repls/GrowingElatedProgrammingtool)

---

template: for-loops-1
name: for-loops-2

```javascript
// infinite loop
for (let i=1; true; i++) {
    console.log(`For loop iteration #${i}`);
}
```

[Try it!](https://repl.it/repls/TiredLeanLanservers)

---

template: basics
name: while-loops-1

## While loops
The expected behavior.

```javascript
// iterate 5 times
let i = 1;
while (i < 6) {
    console.log(`While loop iteration #${i}`);
    i++;
}
```

[Try it!](https://repl.it/repls/DarkmagentaPuzzledUnix)

---

template: while-loops-1
name: while-loops-2

```javascript
let i = 0;
while (true) {
    console.log(`While loop iteration #${i}`);
    i++;
}
```

[Try it!](https://repl.it/repls/NonstopNewOpposites)

---

template: basics
name: comparison-1

## Equality

Javascript performs some type coersion automatically:
```javascript
1 == '1'; // true
true == 1; // true
undefined == null; // true
```

---

template: comparison-1
name: comparison-2

Whereas the `==` compares by coerced value, the `===` operator compares by value but also by type.
```javascript
1 === '1'; // false
true === 1; // false
undefined === null; // false
```

---

name: functions

# Functions

---

template: functions
name: functions-1

## Simple functions
The `function` keyword.

```javascript
// define a function the most simple way
function doSomething1() {
    console.log('doSomething1 is running');
}
doSomething1(); // call the function
```

---

template: functions-1
name: functions-2

```javascript
// define a function the most simple way with two parameters
function doSomething2(x, y) {
    console.log(`doSomething2 is running with x=${x} and y=${y}.`);
}
doSomething2('hello', 'world'); // call the function with arguments
```

---

template: functions-2
name: functions-3

```javascript
// define a function the most simple way with two parameters and a return value
function doSomething3(x, y) {
    const msg = `doSomething3 is running with x=${x} and y=${y}.`;
    return msg;
}
console.log( doSomething3('hello', 'world') ); // call the function and use its return value
```

---

template: functions
name: functions-4

## Anonymous functions
Functions in Javascript can be nameless.

```javascript
// define an anonymous function, but assign a variable to refer to it
const doSomething1 = function () {
    console.log('doSomething1 is running');
}

doSomething1(); // call the function
```

[Try it!](https://repl.it/repls/DeeppinkSecondaryReference)

---

template: functions-4
name: functions-5

```javascript
// define an anonymous function with parameters, but assign a variable to refer to it
const doSomething2 = function (x, y) {
    console.log(`doSomething2 is running with x=${x} and y=${y}.`);
}

doSomething2('hello', 'world'); // call the function with arguments
```

[Try it!](https://repl.it/repls/ShadyNavyblueGravity)

---

template: functions-5
name: functions-6

```javascript
// define an anonymous function with parameters and a return value, but assign a variable to refer to it
const doSomething3 = function (x, y) {
    const msg = `doSomething3 is running with x=${x} and y=${y}.`;
    return msg;
}

console.log( doSomething3('hello', 'world') ); // call the function and use its return value
```

[Try it!](https://repl.it/repls/InferiorRecursiveInitialization)

---

name: arrow-functions

# Arrow functions

---

template: arrow-functions
name: arrow-functions-1

A simplified function syntax without the `function` keyword.

```javascript
// an arrow function with no parameters or return value
const doSomething1 = () => {
    console.log('doSomething1 is running');
}

doSomething1(); // call the function
```

[Try it!](https://repl.it/repls/SoggyReliableEnterprise)

---

template: arrow-functions-1
name: arrow-functions-2

```javascript
// an arrow function with parameters
const doSomething2 = (x, y) => {
    console.log(`doSomething2 is running with x=${x} and y=${y}.`);
}

doSomething2('hello', 'world'); // call the function with arguments
```

[Try it!](https://repl.it/repls/WhirlwindWastefulSeahorse)

---

template: arrow-functions-2
name: arrow-functions-3

```javascript
// an arrow function with parameters and a return value
const doSomething3 = (x, y) => {
    const msg = `doSomething3 is running with x=${x} and y=${y}.`;
    return msg;
}

console.log( doSomething3('hello', 'world') ); // call the function and use its return value
```

[Try it!](https://repl.it/repls/StainedBlueContent)

---

template: arrow-functions
name: arrow-functions-4

Function syntax can be even further reduced.

```javascript
// even further reduced syntax for a function with only a return statement... so no curly braces required
const doSomething4 = (x, y) => `doSomething4 is running with x=${x} and y=${y}.`;
console.log( doSomething4('hello', 'world') ); // call the function and use its return value
```

[Try it!](https://repl.it/repls/SalmonWarpedParentheses)

---

template: arrow-functions-4
name: arrow-functions-5

```javascript
// even further reduced syntax with no parentheses around a single parameter
const doSomething5 = x => `doSomething5 is running with x=${x}.`;
console.log( doSomething5('hello') ); // call the function and use its return value
```

[Try it!](https://repl.it/repls/FunctionalHelplessPresses)

---

template: arrow-functions-5
name: arrow-functions-6

```javascript
// a special shorthand syntax for defining methods within objects
const fido = {
    name: "Fido",
    breed: "Schnauzer",
    bark(message) {
        console.log(`${this.name} the ${this.breed} says, '${message}'`);
    }
}
fido.bark();
```

[Try it!](https://repl.it/repls/ImmaculateHurtfulLink)

---

name: objects

# Objects

---

template: objects
name: objects-1

## Instantiating objects
Javascript objects are usually instantiated directly, without the need for a class.

```javascript
// an object
const me = {
    name: "Foo Barstein",
    phone: "212-666-1212",
    age: 63,
    isRobot: false
};

// add a method to the object on the fly
me.speak = function(message) {
    console.log(`${this.name} says, "${message}".`);
}

me.speak('Hello!'); // expected output: 'Foo Barstein says, "Hello!".'
```

[Try it!](https://repl.it/repls/CultivatedCautiousTrapezoid)
---

template: objects
name: objects-2

## Objects can be sub-classed by simply copying them
Javascript uses prototypal inheritance, where one object uses another as the prototype from which it is based.

```javascript
// make a copy of an object - this is prototypal inheritance
const robotMe = Object.create(me); // creates a new object based on the original prototype
robotMe.isRobot = true; // modify this new object in some way

console.log(`me ${me.isRobot ? 'is indeed' : 'is not'} a robot.`); // expected output: "My name is Foo Barstein"
console.log(`robotMe ${robotMe.isRobot ? 'is indeed' : 'is not'} a robot.`); // expected output: "My name is Foo Barstein"
```

[Try it!](https://repl.it/repls/BouncyQueasyLists)

---

template: objects
name: objects-3

## Methods in objects
The `this` keyword refers to the object a method is called on. The method is declared in a shorthand syntax

```javascript
// an object with a method belonging to it
const fido = {
    name: "Fido",
    breed: "Schnauzer",
    bark(message) {
        console.log(`${this.name} the ${this.breed} says, '${message}'`);
    }
}

// call the bark method on the fido object
fido.bark('Woof!'); //expected output: "Fido the Schnauzer says, 'Woof!'"
```

[Try it!](https://repl.it/repls/BurlyCircularSystemresource)

---

template: objects
name: objects-4

## Constructing objects with a function caall
Objects can alternatively be instantiated by calling a function.

```javascript
function Dog(name, breed) {
    this.name = name;
    this.breed = breed;
    this.bark = (message) => {
        console.log(`${this.name} the ${this.breed} says, '${message}'`);
    }
}

// instantiate an object and call its method
let fido = new Dog('Fido', 'Schnauzer');
fido.bark('Woof!');
```

[Try it!](https://repl.it/repls/OverjoyedMurkyFlashmemory)

---

template: objects
name: objects-5

## Constructing objects with a class definition
Objects can alternatively be instantiated with from a class definition.  This is `syntactic sugar` and not a real feature of the language.

```javascript
class Dog {
    constructor(name, breed) {
        this.name = name;
        this.breed = breed;
    }
    bark(message) {
        console.log(`${this.name} the ${this.breed} says, '${message}'`);
    }
}

// instantiate an object and call its method
let fido = new Dog('Fido', 'Schnauzer');
fido.bark('Woof!');
```

[Try it!](https://repl.it/repls/FancyKhakiZip)

---

name: arrays

# Arrays

---

template: arrays
name: arrays-1

## Basics
Arrays behave as expected.

```javascript
// generate an array from a string
let fruits = "avocado,tomato,banana".split(","); // returns ['avocado, 'tomato', 'banana']
console.log(`Do you love ${fruits[1]}?`); // expected output "Do you love tomato?"
```

---

template: arrays-1
name: arrays-2

```javascript
// add an element to an array
fruits.push("pepper"); // fruits now has ['avocado, 'tomato', 'banana', 'pepper']
```

---

template: arrays-2
name: arrays-3

```javascript
// find index position of element by value
const fruit = 'pepper';
let pos = fruits.indexOf(fruit); // returns 3
console.log(`${fruit} is located in the array at index ${pos}.`);
```

---

template: arrays
name: arrays-4

## Basics 
Continued.
```javascript
// delete last element from the array
fruits.pop(); // fruits now has ['avocado, 'tomato', 'banana']
```

---

template: arrays-4
name: arrays-5

```javascript
// indexOf returns -1 if value not found in arraay
pos = fruits.indexOf('pepper'); // 'pepper' is no longer there, so -1 is returned
console.log(`${fruit} is now located in the array at index ${pos}.`);
```

---

template: arrays-5
name: arrays-6

```javascript
// join all elements in array into a comma-separated string
const stringAgain = fruits.join(','); returns 'avocado,tomato, banana'
console.log(`The fruits are ${stringAgain}.`);
```

---

template: arrays
name: arrays-7

## Map function
Iterates through array values.
```javascript
// iterate through each value in array and pass it as an argument to a function
fruits.map( (val) => {
    console.log(`This fruit is ${val}!`);
} );

```

---

template: arrays
name: arrays-8

## Filter function
Create a subset of an array.
```javascript
// create a new array with a subset of the original values
fruits = fruits.filter( (val, i, arr) => {
    return val != 'banana'; // returns true for all fruits except 'banana'
} );

console.log(fruits); // expected output: ['avocado', 'tomato']
```

---

template: arrays
name: arrays-9

## Arrays of objects
A common data format used by [APIs](#apis) to pass data between clients and servers.
```javascript
const products = [
   {
     id: 1,
     title: 'Boa, emerald green tree',
     price: '$31.82',
     description: 'Sed ante. Vivamus tortor. Duis mattis egestas metus.'
   },
   {
     id: 2,
     title: 'Bleu, blue-breasted cordon',
     price: '$35.66',
     description: 'Praesent blandit. Nam nulla. Integer pede justo, lacinia eget, tincidunt eget, tempus vel, pede.'
   } // imagine there were more product objects...
];
```

```javascript
// loop through each product
products.map( (product) => {
    // print the title and price of each product
    console.log(`${product.title} - ${product.price}`)
});
```

---

name: higher-order-functions

# Higher Order Functions

---

template: higher-order-functions
name: higher-order-functions-1

Functions can be passed as arguments to other functions.

```javascript
// a simple function that prints out its argument
const foo = (val) => { 
    console.log(`val = ${val}`) 
};
```

---

template: higher-order-functions-1
name: higher-order-functions-2

```javascript
// another function that takes another function as its argument
const bar = (func, arg) => {
    func(arg); // call the function that was received, whatever it is, and pass it the argument that was received
}
```

---

template: higher-order-functions-2
name: higher-order-functions-3

```javascript
// pass the foo function to the bar function as an argument
bar(foo, 5);
```

[Try it!](https://repl.it/repls/UnacceptableUselessPriority)
---

name: asynchronicity

# Asynchronicity

---

template: asynchronicity
name: asynchronicity-1

## Overview
Javascript has three features to handle asynchronicity in code.
- Callbacks
- Promises
- Async/await

---

template: asynchronicity
name: asynchronicity-2

## Callbacks
Callbacks are functions that will be called when a certain task completes.

```javascript
// a function that accepts two callbacks - one for success, one for failure
let doIt = (callbackSuccess, callbackFailure) => {
    /* imagine this function did an asynchronous task and then...:
     *  - called callbackSuccess() function if task is successful
     *  - called callbackFailure() function if task failed */
}

// call the function, pass two callback functions to handle its success or failure
doIt( 
    res => { console.log(`Success: ${res}`); },
    err => { console.log(`Failure: ${err}`); } 
);
```

[Try it!](https://repl.it/repls/EarnestSimplisticMicroprogramming)

---

template: asynchronicity
name: asynchronicity-2

## Promises
Promises are a language feature that allow programmers to specify two functions: one to be called automatically when a certain asynchronous task is successfully completed and another to be called when that task fails.

```javascript
// a function that returns a Promise
let doIt = () => {
    return new Promise( (resolve, reject) => {
        /* imagine this function did an asynchronous task and then...:
        *  - called resolve('hooraah') if task is successful
        *  - called reject('boo!') if task failed */
    });
}

// call the function, pass functions to handle its success or failure, whenever it completes
doIt()
  .then( res => { console.log(`Success: ${res}`); } )
  .catch( err => { console.log(`Failure: ${err}`); } )
```

[Try it!](https://repl.it/repls/SnappyStaidJavabytecode);

---

template: asynchronicity
name: asynchronicity-3

## Async
The `async` keyword works on top of Promises to make their syntax simpler to read.  
- It can be placed in front of any function definition - this means the function's return value is guaranteed to be returned as a Promise, regardless of what the return statement says.

```javascript
let doIt = async () => {
    // this function automatically returns a Promise, even if it doesn't say so
    return 'hoorah!';
}

// treat the function as if it returned a Promise, because it does!
doIt()
  .then( res => { console.log(`Success: ${res}`); } )
```

[Try it!]()

---

template: asynchronicity
name: asynchronicity-4

## Await
The `await` keyword can be used within any `async` function.  
- `await` forces the program to wait for a Promise to complete before moving on to the next line of code.

```javascript
let doIt = async () => {
    /* imagine this function did an asynchronous task and then...:
    *  - waited for the task to complete...
    *  - returned the result of the task
}
// call the function, pass functions to handle its success or failure, whenever it completes
doIt()
  .then( res => { console.log(`Success: ${res}`); } )
  .catch( err => { console.log(`Failure: ${err}`);} );
```

[Try it!](https://repl.it/repls/ImmaculateSerpentineConditions)

---

name: apis

# Using APIs

---

template: apis
name: apis-1

## Concept
When a client requests data from a server, that data must be returned in a particular format the client can parse.
- The servers always return text (i.e. strings) in their HTTP responses
- For simple static web content, that format of the data is simple HTML returned by the server
- For more complex needs, [Javascript Object Notation](https://knowledge.kitchen/Introduction_to_JSON) (JSON) is the preferred format.
- Once on the client side, this JSON is interpreted as Javascript code.

---

template: apis
name: apis-3

## Example
Fetching data from APIs requires asynchronous programming.
```javascript
const https = require('https'); // using Node's built-in http module for http requests
const apiUrl = "https://my.api.mockaroo.com/users.json?key=d9ddfc40"; // a mock-API for demo purposes that returns a JSON array of objects

// make an HTTP request to the API server
https.get(apiUrl, (response) => {

  response.on('data', (chunk) => {
    // this callback function is called automatically every time a chunk of data has been recieved from the server.
  });

  response.on('end', () => {
    // this callback function is caalled automatically when all data has been received from API
  });
  
}).on("error", (err) => {
  // this callback function is called automatically if there is an error
});
```

[Try it!](https://repl.it/repls/FaroffImpureCells)
- [See the raw data returned by the API](https://my.api.mockaroo.com/users.json?key=d9ddfc40):

---

name: destructuring

# Destructuring

---

template: destructuring
name: destructuring-1

## Arrays
Values in an array can be extracted into separate variables upon assignment:
```javascript
// asssign the first two values in an array to two variables in one statement
const [a, b] = [10, 20, 30, 40, 50]; // a=10, b=20
```

---

template: destructuring-1
name: destructuring-2

The remaining values can be lumped together:
```javascript
const [c, d, ...rest] = [10, 20, 30, 40, 50]; // c=10, d=20, rest=[30,40,50]
```

---

template: destructuring-2
name: destructuring-3

Function parameters can follow this same syntax:
```javascript
function foo(a, b, ...args) {
    console.log(`a = ${a}`); // expected output: 10
    console.log(`b = ${b}`); // expected output: 20
    console.log(`args = ${args}`); // expected output: [30,40,50]
}
foo(10, 20, 30, 40, 50); // pass values as separate arguments
```

---

template: destructuring
name: destructuring-4

## Objects
Values within an object can be destructured.
```javascript
// destructuring can also be done with objects
const person = {
    age: 72, 
    name: "Foo Barstein",
    email: 'fb1258@teleworm.us',
    address: {
        street: '92 Rue Jamil Sedki',
        city: 'Beni Brahim',
        country: 'Tunisia',
        postalCode: 7040
    } 
};
```

---

template: destructuring-4
name: destructuring-5

```javascript
const {name, age} = person; // name='Foo Barstein', age=72
console.log(`name = ${name}`); // expected output: 'Foo Barstein'
console.log(`age = ${age}`); // expected output: 72
```

---

template: destructuring
name: destructuring-6

## Objects

Variable names do not need to match field names in the objects being destructured:
```javascript
const {name : fullName, age : apparentAge} = person; // { fullName: 'Foo Barstein', apparentAge: 72 }
console.log(`fullName = ${fullName}`); // expected output: 'Foo Barstein'
console.log(`apparentAge = ${apparentAge}`); // expected output: 72
```

---

template: destructuring-6
name: destructuring-7

Nested objects can be destructured as well:
```javascript
const {
    email,
    address: {
        city // create a variable for this field only
    }
} = person;
console.log(`email = ${email}`); // expected output: 'fb1258@teleworm.us'
console.log(`city = ${city}`); // expected output: 'Beni Brahim''
```

---

name: importing

# Importing & Exporting

---

template: importing
name: importing-1

## Concept
Javascript today allows modular reuse of your own code or that of 3rd parties through its module functionality.

---

template: importing-1
name: importing-2

- the Node Package Manager (NPM) provides easy ways to manage the download, installation, and configuration of open soure 3rd party code libraries.

---

template: importing-2
name: importing-3

- Node supports two different ways of importing/exporting modules: the [CommonJS](https://en.wikipedia.org/wiki/CommonJS) way, and the [ECMAScript 2015](https://en.wikipedia.org/wiki/ECMAScript#6th_Edition_-_ECMAScript_2015) (ES6) way - these are competing standards.

---

template: importing-3
name: importing-4

- Node originally supported the CommonJS module specification before ES6 was released, since there was nothing in the ECMAScript specification for importing/exporting at that time.

---

template: importing-4
name: importing-5

- Once ES6 arrived, Node added support for its module specification, but a special `'type': 'module'` setting must be added to every Node project's config file named `package.json` for the ES6 module functionality to kick in.

---

template: importing
name: importing-1

## CommonJS exporting

Basic CommonJS exporting syntax:
```javascript
// imagine you had a variable foo, a function bar, and an object baz - all can be exported

// export these all to make them available for import into another Javscript file
module.exports = {foo , bar, baz}; // note the CommonJS syntax!
```

With CommonJS, you could also have exported each variable individually:
```javascript
module.exports.foo = 5; // a number
module.exports.bar = () => { console.log('hello world!') }; // a function
module.exports.baz = { x: 5, y: 10 }; // an object
```

Or even without the `module` prefix:
```javascript
exports.foo = 5; // a number
exports.bar = () => { console.log('hello world!') }; // a function
exports.baz = { x: 5, y: 10 }; // an object
```

---

template: importing
name: importing-3

## CommonJS importing

Import named exports using the `require` function:
```javascript
const { foo, bar, baz } = require('./10.exporting'); 
```

Or import the entire module and access the named exports separately:
```javascript
const myModule = require('./10.exporting'); // import module as a whole

console.log(myModule.foo); // access a value exported in the module
myModule.bar(); // access a function exported in the module
```

---

template: importing
name: importing-2

## ES6 exporting
Basic ES6 exporting syntax:
```javascript
// imagine you had a variable foo, a function bar, and an object baz - all can be exported

// export these all to make them available for import into another Javscript file
export {foo , bar, baz}; // note the ES6 syntax!
```

With ES6, you could also have exported each variable individually:
```javascript
export let foo = 5; // a number
export let bar = () => { console.log('hello world!') }; // a function
export let baz = { x: 5, y: 10 }; // an object
```

Or you can specify one of them as the `default` export, if desired:
```javascript
export let foo = 5; // a number
export default let bar = () => { console.log('hello world!') }; // a function
export let baz = { x: 5, y: 10 }; // an object
```


---

template: importing
name: importing-4

## ES6 importing

Import named exports using the `import` keyword:
```javascript
import { foo, bar, baz } from './10.exporting';
```

Or give each import a different name than in the module:
```javascript
import { foo as f, bar as b1, baz as b2 } from './10.exporting';
```

If the module specified a `default` export, we can import only that - note the syntax:
```javascript
import bar from './10.exporting';
```

We can also import the default export in combination with some named exports:
```javascript
import bar, {foo, baz} from './10.exporting'; // the default export is 'bar'
```

---

name: implementations

# Web Browser Implementations vs. Node.js Implementations

---

template: implementations
name: implementations-1

## Differences
Javascript can be run either *within a web page* loaded by a web browser (i.e. client-side) or *on an HTTP server* using Node.js.  There are some key differences.

---

template: implementations-1
name: implementations-2

- *Javascript in the web browser* is primarily focused on interacting with the browser's [Document Object Model](https://knowledge.kitchen/Document_Object_Model) (DOM) - an object created automatically by the browser itself that contains and allows the Javsacript to modify all the contents, styles, and behaviors of the web page currently loaded in the browser's memory. 

---

template: implementations-2
name: implementations-3

- *Node.js runs on the server*, where there is no currently-loaded web page.  So the DOM does not exist and is not of any use in controlling server behavior.  Node.js has its own set of [built-in variables and objects](https://knowledge.kitchen/Node.js_notes#Global_variables).

---

template: implementations
name: implementations-4

## Differences (continued)
- There are *myriad web browsers* with *myriad different versions* in active use by people across The Web.  Programming Javascript that will work in all of them usually means taking a 8lowest-common denominator approach* and sticking to language features that have been around for many years.

---

template: implementations-4
name: implementations-5

- Unlike with the web browser, *you control the server*, including which version of Javascript is supported.  So you can guarantee support for whichever version of Node.js you choose to program in.

---

name: conclusions

# Conclusions

---

template: conclusions
name: conclusions-1

You are now primed dive into the web browser's implementation of Javascript, as well as configuring projects with NPM and Express.js and React's implementations!
- Thank you.  Bye


